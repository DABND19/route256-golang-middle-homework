package domain

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/checkout/internal/domain.TransactionRunner -o ./zzz_transaction_runner.go -n TransactionRunnerMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// TransactionRunnerMock implements TransactionRunner
type TransactionRunnerMock struct {
	t minimock.Tester

	funcRunInSavepoint          func(ctx context.Context, txFn func(ctx context.Context) error) (err error)
	inspectFuncRunInSavepoint   func(ctx context.Context, txFn func(ctx context.Context) error)
	afterRunInSavepointCounter  uint64
	beforeRunInSavepointCounter uint64
	RunInSavepointMock          mTransactionRunnerMockRunInSavepoint

	funcRunReadCommited          func(ctx context.Context, txFn func(ctx context.Context) error) (err error)
	inspectFuncRunReadCommited   func(ctx context.Context, txFn func(ctx context.Context) error)
	afterRunReadCommitedCounter  uint64
	beforeRunReadCommitedCounter uint64
	RunReadCommitedMock          mTransactionRunnerMockRunReadCommited

	funcRunRepeatableRead          func(ctx context.Context, txFn func(ctx context.Context) error) (err error)
	inspectFuncRunRepeatableRead   func(ctx context.Context, txFn func(ctx context.Context) error)
	afterRunRepeatableReadCounter  uint64
	beforeRunRepeatableReadCounter uint64
	RunRepeatableReadMock          mTransactionRunnerMockRunRepeatableRead

	funcRunSerializable          func(ctx context.Context, txFn func(ctx context.Context) error) (err error)
	inspectFuncRunSerializable   func(ctx context.Context, txFn func(ctx context.Context) error)
	afterRunSerializableCounter  uint64
	beforeRunSerializableCounter uint64
	RunSerializableMock          mTransactionRunnerMockRunSerializable
}

// NewTransactionRunnerMock returns a mock for TransactionRunner
func NewTransactionRunnerMock(t minimock.Tester) *TransactionRunnerMock {
	m := &TransactionRunnerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.RunInSavepointMock = mTransactionRunnerMockRunInSavepoint{mock: m}
	m.RunInSavepointMock.callArgs = []*TransactionRunnerMockRunInSavepointParams{}

	m.RunReadCommitedMock = mTransactionRunnerMockRunReadCommited{mock: m}
	m.RunReadCommitedMock.callArgs = []*TransactionRunnerMockRunReadCommitedParams{}

	m.RunRepeatableReadMock = mTransactionRunnerMockRunRepeatableRead{mock: m}
	m.RunRepeatableReadMock.callArgs = []*TransactionRunnerMockRunRepeatableReadParams{}

	m.RunSerializableMock = mTransactionRunnerMockRunSerializable{mock: m}
	m.RunSerializableMock.callArgs = []*TransactionRunnerMockRunSerializableParams{}

	return m
}

type mTransactionRunnerMockRunInSavepoint struct {
	mock               *TransactionRunnerMock
	defaultExpectation *TransactionRunnerMockRunInSavepointExpectation
	expectations       []*TransactionRunnerMockRunInSavepointExpectation

	callArgs []*TransactionRunnerMockRunInSavepointParams
	mutex    sync.RWMutex
}

// TransactionRunnerMockRunInSavepointExpectation specifies expectation struct of the TransactionRunner.RunInSavepoint
type TransactionRunnerMockRunInSavepointExpectation struct {
	mock    *TransactionRunnerMock
	params  *TransactionRunnerMockRunInSavepointParams
	results *TransactionRunnerMockRunInSavepointResults
	Counter uint64
}

// TransactionRunnerMockRunInSavepointParams contains parameters of the TransactionRunner.RunInSavepoint
type TransactionRunnerMockRunInSavepointParams struct {
	ctx  context.Context
	txFn func(ctx context.Context) error
}

// TransactionRunnerMockRunInSavepointResults contains results of the TransactionRunner.RunInSavepoint
type TransactionRunnerMockRunInSavepointResults struct {
	err error
}

// Expect sets up expected params for TransactionRunner.RunInSavepoint
func (mmRunInSavepoint *mTransactionRunnerMockRunInSavepoint) Expect(ctx context.Context, txFn func(ctx context.Context) error) *mTransactionRunnerMockRunInSavepoint {
	if mmRunInSavepoint.mock.funcRunInSavepoint != nil {
		mmRunInSavepoint.mock.t.Fatalf("TransactionRunnerMock.RunInSavepoint mock is already set by Set")
	}

	if mmRunInSavepoint.defaultExpectation == nil {
		mmRunInSavepoint.defaultExpectation = &TransactionRunnerMockRunInSavepointExpectation{}
	}

	mmRunInSavepoint.defaultExpectation.params = &TransactionRunnerMockRunInSavepointParams{ctx, txFn}
	for _, e := range mmRunInSavepoint.expectations {
		if minimock.Equal(e.params, mmRunInSavepoint.defaultExpectation.params) {
			mmRunInSavepoint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRunInSavepoint.defaultExpectation.params)
		}
	}

	return mmRunInSavepoint
}

// Inspect accepts an inspector function that has same arguments as the TransactionRunner.RunInSavepoint
func (mmRunInSavepoint *mTransactionRunnerMockRunInSavepoint) Inspect(f func(ctx context.Context, txFn func(ctx context.Context) error)) *mTransactionRunnerMockRunInSavepoint {
	if mmRunInSavepoint.mock.inspectFuncRunInSavepoint != nil {
		mmRunInSavepoint.mock.t.Fatalf("Inspect function is already set for TransactionRunnerMock.RunInSavepoint")
	}

	mmRunInSavepoint.mock.inspectFuncRunInSavepoint = f

	return mmRunInSavepoint
}

// Return sets up results that will be returned by TransactionRunner.RunInSavepoint
func (mmRunInSavepoint *mTransactionRunnerMockRunInSavepoint) Return(err error) *TransactionRunnerMock {
	if mmRunInSavepoint.mock.funcRunInSavepoint != nil {
		mmRunInSavepoint.mock.t.Fatalf("TransactionRunnerMock.RunInSavepoint mock is already set by Set")
	}

	if mmRunInSavepoint.defaultExpectation == nil {
		mmRunInSavepoint.defaultExpectation = &TransactionRunnerMockRunInSavepointExpectation{mock: mmRunInSavepoint.mock}
	}
	mmRunInSavepoint.defaultExpectation.results = &TransactionRunnerMockRunInSavepointResults{err}
	return mmRunInSavepoint.mock
}

// Set uses given function f to mock the TransactionRunner.RunInSavepoint method
func (mmRunInSavepoint *mTransactionRunnerMockRunInSavepoint) Set(f func(ctx context.Context, txFn func(ctx context.Context) error) (err error)) *TransactionRunnerMock {
	if mmRunInSavepoint.defaultExpectation != nil {
		mmRunInSavepoint.mock.t.Fatalf("Default expectation is already set for the TransactionRunner.RunInSavepoint method")
	}

	if len(mmRunInSavepoint.expectations) > 0 {
		mmRunInSavepoint.mock.t.Fatalf("Some expectations are already set for the TransactionRunner.RunInSavepoint method")
	}

	mmRunInSavepoint.mock.funcRunInSavepoint = f
	return mmRunInSavepoint.mock
}

// When sets expectation for the TransactionRunner.RunInSavepoint which will trigger the result defined by the following
// Then helper
func (mmRunInSavepoint *mTransactionRunnerMockRunInSavepoint) When(ctx context.Context, txFn func(ctx context.Context) error) *TransactionRunnerMockRunInSavepointExpectation {
	if mmRunInSavepoint.mock.funcRunInSavepoint != nil {
		mmRunInSavepoint.mock.t.Fatalf("TransactionRunnerMock.RunInSavepoint mock is already set by Set")
	}

	expectation := &TransactionRunnerMockRunInSavepointExpectation{
		mock:   mmRunInSavepoint.mock,
		params: &TransactionRunnerMockRunInSavepointParams{ctx, txFn},
	}
	mmRunInSavepoint.expectations = append(mmRunInSavepoint.expectations, expectation)
	return expectation
}

// Then sets up TransactionRunner.RunInSavepoint return parameters for the expectation previously defined by the When method
func (e *TransactionRunnerMockRunInSavepointExpectation) Then(err error) *TransactionRunnerMock {
	e.results = &TransactionRunnerMockRunInSavepointResults{err}
	return e.mock
}

// RunInSavepoint implements TransactionRunner
func (mmRunInSavepoint *TransactionRunnerMock) RunInSavepoint(ctx context.Context, txFn func(ctx context.Context) error) (err error) {
	mm_atomic.AddUint64(&mmRunInSavepoint.beforeRunInSavepointCounter, 1)
	defer mm_atomic.AddUint64(&mmRunInSavepoint.afterRunInSavepointCounter, 1)

	if mmRunInSavepoint.inspectFuncRunInSavepoint != nil {
		mmRunInSavepoint.inspectFuncRunInSavepoint(ctx, txFn)
	}

	mm_params := &TransactionRunnerMockRunInSavepointParams{ctx, txFn}

	// Record call args
	mmRunInSavepoint.RunInSavepointMock.mutex.Lock()
	mmRunInSavepoint.RunInSavepointMock.callArgs = append(mmRunInSavepoint.RunInSavepointMock.callArgs, mm_params)
	mmRunInSavepoint.RunInSavepointMock.mutex.Unlock()

	for _, e := range mmRunInSavepoint.RunInSavepointMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRunInSavepoint.RunInSavepointMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRunInSavepoint.RunInSavepointMock.defaultExpectation.Counter, 1)
		mm_want := mmRunInSavepoint.RunInSavepointMock.defaultExpectation.params
		mm_got := TransactionRunnerMockRunInSavepointParams{ctx, txFn}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRunInSavepoint.t.Errorf("TransactionRunnerMock.RunInSavepoint got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRunInSavepoint.RunInSavepointMock.defaultExpectation.results
		if mm_results == nil {
			mmRunInSavepoint.t.Fatal("No results are set for the TransactionRunnerMock.RunInSavepoint")
		}
		return (*mm_results).err
	}
	if mmRunInSavepoint.funcRunInSavepoint != nil {
		return mmRunInSavepoint.funcRunInSavepoint(ctx, txFn)
	}
	mmRunInSavepoint.t.Fatalf("Unexpected call to TransactionRunnerMock.RunInSavepoint. %v %v", ctx, txFn)
	return
}

// RunInSavepointAfterCounter returns a count of finished TransactionRunnerMock.RunInSavepoint invocations
func (mmRunInSavepoint *TransactionRunnerMock) RunInSavepointAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRunInSavepoint.afterRunInSavepointCounter)
}

// RunInSavepointBeforeCounter returns a count of TransactionRunnerMock.RunInSavepoint invocations
func (mmRunInSavepoint *TransactionRunnerMock) RunInSavepointBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRunInSavepoint.beforeRunInSavepointCounter)
}

// Calls returns a list of arguments used in each call to TransactionRunnerMock.RunInSavepoint.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRunInSavepoint *mTransactionRunnerMockRunInSavepoint) Calls() []*TransactionRunnerMockRunInSavepointParams {
	mmRunInSavepoint.mutex.RLock()

	argCopy := make([]*TransactionRunnerMockRunInSavepointParams, len(mmRunInSavepoint.callArgs))
	copy(argCopy, mmRunInSavepoint.callArgs)

	mmRunInSavepoint.mutex.RUnlock()

	return argCopy
}

// MinimockRunInSavepointDone returns true if the count of the RunInSavepoint invocations corresponds
// the number of defined expectations
func (m *TransactionRunnerMock) MinimockRunInSavepointDone() bool {
	for _, e := range m.RunInSavepointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RunInSavepointMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRunInSavepointCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRunInSavepoint != nil && mm_atomic.LoadUint64(&m.afterRunInSavepointCounter) < 1 {
		return false
	}
	return true
}

// MinimockRunInSavepointInspect logs each unmet expectation
func (m *TransactionRunnerMock) MinimockRunInSavepointInspect() {
	for _, e := range m.RunInSavepointMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionRunnerMock.RunInSavepoint with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RunInSavepointMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRunInSavepointCounter) < 1 {
		if m.RunInSavepointMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TransactionRunnerMock.RunInSavepoint")
		} else {
			m.t.Errorf("Expected call to TransactionRunnerMock.RunInSavepoint with params: %#v", *m.RunInSavepointMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRunInSavepoint != nil && mm_atomic.LoadUint64(&m.afterRunInSavepointCounter) < 1 {
		m.t.Error("Expected call to TransactionRunnerMock.RunInSavepoint")
	}
}

type mTransactionRunnerMockRunReadCommited struct {
	mock               *TransactionRunnerMock
	defaultExpectation *TransactionRunnerMockRunReadCommitedExpectation
	expectations       []*TransactionRunnerMockRunReadCommitedExpectation

	callArgs []*TransactionRunnerMockRunReadCommitedParams
	mutex    sync.RWMutex
}

// TransactionRunnerMockRunReadCommitedExpectation specifies expectation struct of the TransactionRunner.RunReadCommited
type TransactionRunnerMockRunReadCommitedExpectation struct {
	mock    *TransactionRunnerMock
	params  *TransactionRunnerMockRunReadCommitedParams
	results *TransactionRunnerMockRunReadCommitedResults
	Counter uint64
}

// TransactionRunnerMockRunReadCommitedParams contains parameters of the TransactionRunner.RunReadCommited
type TransactionRunnerMockRunReadCommitedParams struct {
	ctx  context.Context
	txFn func(ctx context.Context) error
}

// TransactionRunnerMockRunReadCommitedResults contains results of the TransactionRunner.RunReadCommited
type TransactionRunnerMockRunReadCommitedResults struct {
	err error
}

// Expect sets up expected params for TransactionRunner.RunReadCommited
func (mmRunReadCommited *mTransactionRunnerMockRunReadCommited) Expect(ctx context.Context, txFn func(ctx context.Context) error) *mTransactionRunnerMockRunReadCommited {
	if mmRunReadCommited.mock.funcRunReadCommited != nil {
		mmRunReadCommited.mock.t.Fatalf("TransactionRunnerMock.RunReadCommited mock is already set by Set")
	}

	if mmRunReadCommited.defaultExpectation == nil {
		mmRunReadCommited.defaultExpectation = &TransactionRunnerMockRunReadCommitedExpectation{}
	}

	mmRunReadCommited.defaultExpectation.params = &TransactionRunnerMockRunReadCommitedParams{ctx, txFn}
	for _, e := range mmRunReadCommited.expectations {
		if minimock.Equal(e.params, mmRunReadCommited.defaultExpectation.params) {
			mmRunReadCommited.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRunReadCommited.defaultExpectation.params)
		}
	}

	return mmRunReadCommited
}

// Inspect accepts an inspector function that has same arguments as the TransactionRunner.RunReadCommited
func (mmRunReadCommited *mTransactionRunnerMockRunReadCommited) Inspect(f func(ctx context.Context, txFn func(ctx context.Context) error)) *mTransactionRunnerMockRunReadCommited {
	if mmRunReadCommited.mock.inspectFuncRunReadCommited != nil {
		mmRunReadCommited.mock.t.Fatalf("Inspect function is already set for TransactionRunnerMock.RunReadCommited")
	}

	mmRunReadCommited.mock.inspectFuncRunReadCommited = f

	return mmRunReadCommited
}

// Return sets up results that will be returned by TransactionRunner.RunReadCommited
func (mmRunReadCommited *mTransactionRunnerMockRunReadCommited) Return(err error) *TransactionRunnerMock {
	if mmRunReadCommited.mock.funcRunReadCommited != nil {
		mmRunReadCommited.mock.t.Fatalf("TransactionRunnerMock.RunReadCommited mock is already set by Set")
	}

	if mmRunReadCommited.defaultExpectation == nil {
		mmRunReadCommited.defaultExpectation = &TransactionRunnerMockRunReadCommitedExpectation{mock: mmRunReadCommited.mock}
	}
	mmRunReadCommited.defaultExpectation.results = &TransactionRunnerMockRunReadCommitedResults{err}
	return mmRunReadCommited.mock
}

// Set uses given function f to mock the TransactionRunner.RunReadCommited method
func (mmRunReadCommited *mTransactionRunnerMockRunReadCommited) Set(f func(ctx context.Context, txFn func(ctx context.Context) error) (err error)) *TransactionRunnerMock {
	if mmRunReadCommited.defaultExpectation != nil {
		mmRunReadCommited.mock.t.Fatalf("Default expectation is already set for the TransactionRunner.RunReadCommited method")
	}

	if len(mmRunReadCommited.expectations) > 0 {
		mmRunReadCommited.mock.t.Fatalf("Some expectations are already set for the TransactionRunner.RunReadCommited method")
	}

	mmRunReadCommited.mock.funcRunReadCommited = f
	return mmRunReadCommited.mock
}

// When sets expectation for the TransactionRunner.RunReadCommited which will trigger the result defined by the following
// Then helper
func (mmRunReadCommited *mTransactionRunnerMockRunReadCommited) When(ctx context.Context, txFn func(ctx context.Context) error) *TransactionRunnerMockRunReadCommitedExpectation {
	if mmRunReadCommited.mock.funcRunReadCommited != nil {
		mmRunReadCommited.mock.t.Fatalf("TransactionRunnerMock.RunReadCommited mock is already set by Set")
	}

	expectation := &TransactionRunnerMockRunReadCommitedExpectation{
		mock:   mmRunReadCommited.mock,
		params: &TransactionRunnerMockRunReadCommitedParams{ctx, txFn},
	}
	mmRunReadCommited.expectations = append(mmRunReadCommited.expectations, expectation)
	return expectation
}

// Then sets up TransactionRunner.RunReadCommited return parameters for the expectation previously defined by the When method
func (e *TransactionRunnerMockRunReadCommitedExpectation) Then(err error) *TransactionRunnerMock {
	e.results = &TransactionRunnerMockRunReadCommitedResults{err}
	return e.mock
}

// RunReadCommited implements TransactionRunner
func (mmRunReadCommited *TransactionRunnerMock) RunReadCommited(ctx context.Context, txFn func(ctx context.Context) error) (err error) {
	mm_atomic.AddUint64(&mmRunReadCommited.beforeRunReadCommitedCounter, 1)
	defer mm_atomic.AddUint64(&mmRunReadCommited.afterRunReadCommitedCounter, 1)

	if mmRunReadCommited.inspectFuncRunReadCommited != nil {
		mmRunReadCommited.inspectFuncRunReadCommited(ctx, txFn)
	}

	mm_params := &TransactionRunnerMockRunReadCommitedParams{ctx, txFn}

	// Record call args
	mmRunReadCommited.RunReadCommitedMock.mutex.Lock()
	mmRunReadCommited.RunReadCommitedMock.callArgs = append(mmRunReadCommited.RunReadCommitedMock.callArgs, mm_params)
	mmRunReadCommited.RunReadCommitedMock.mutex.Unlock()

	for _, e := range mmRunReadCommited.RunReadCommitedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRunReadCommited.RunReadCommitedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRunReadCommited.RunReadCommitedMock.defaultExpectation.Counter, 1)
		mm_want := mmRunReadCommited.RunReadCommitedMock.defaultExpectation.params
		mm_got := TransactionRunnerMockRunReadCommitedParams{ctx, txFn}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRunReadCommited.t.Errorf("TransactionRunnerMock.RunReadCommited got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRunReadCommited.RunReadCommitedMock.defaultExpectation.results
		if mm_results == nil {
			mmRunReadCommited.t.Fatal("No results are set for the TransactionRunnerMock.RunReadCommited")
		}
		return (*mm_results).err
	}
	if mmRunReadCommited.funcRunReadCommited != nil {
		return mmRunReadCommited.funcRunReadCommited(ctx, txFn)
	}
	mmRunReadCommited.t.Fatalf("Unexpected call to TransactionRunnerMock.RunReadCommited. %v %v", ctx, txFn)
	return
}

// RunReadCommitedAfterCounter returns a count of finished TransactionRunnerMock.RunReadCommited invocations
func (mmRunReadCommited *TransactionRunnerMock) RunReadCommitedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRunReadCommited.afterRunReadCommitedCounter)
}

// RunReadCommitedBeforeCounter returns a count of TransactionRunnerMock.RunReadCommited invocations
func (mmRunReadCommited *TransactionRunnerMock) RunReadCommitedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRunReadCommited.beforeRunReadCommitedCounter)
}

// Calls returns a list of arguments used in each call to TransactionRunnerMock.RunReadCommited.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRunReadCommited *mTransactionRunnerMockRunReadCommited) Calls() []*TransactionRunnerMockRunReadCommitedParams {
	mmRunReadCommited.mutex.RLock()

	argCopy := make([]*TransactionRunnerMockRunReadCommitedParams, len(mmRunReadCommited.callArgs))
	copy(argCopy, mmRunReadCommited.callArgs)

	mmRunReadCommited.mutex.RUnlock()

	return argCopy
}

// MinimockRunReadCommitedDone returns true if the count of the RunReadCommited invocations corresponds
// the number of defined expectations
func (m *TransactionRunnerMock) MinimockRunReadCommitedDone() bool {
	for _, e := range m.RunReadCommitedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RunReadCommitedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRunReadCommitedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRunReadCommited != nil && mm_atomic.LoadUint64(&m.afterRunReadCommitedCounter) < 1 {
		return false
	}
	return true
}

// MinimockRunReadCommitedInspect logs each unmet expectation
func (m *TransactionRunnerMock) MinimockRunReadCommitedInspect() {
	for _, e := range m.RunReadCommitedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionRunnerMock.RunReadCommited with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RunReadCommitedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRunReadCommitedCounter) < 1 {
		if m.RunReadCommitedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TransactionRunnerMock.RunReadCommited")
		} else {
			m.t.Errorf("Expected call to TransactionRunnerMock.RunReadCommited with params: %#v", *m.RunReadCommitedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRunReadCommited != nil && mm_atomic.LoadUint64(&m.afterRunReadCommitedCounter) < 1 {
		m.t.Error("Expected call to TransactionRunnerMock.RunReadCommited")
	}
}

type mTransactionRunnerMockRunRepeatableRead struct {
	mock               *TransactionRunnerMock
	defaultExpectation *TransactionRunnerMockRunRepeatableReadExpectation
	expectations       []*TransactionRunnerMockRunRepeatableReadExpectation

	callArgs []*TransactionRunnerMockRunRepeatableReadParams
	mutex    sync.RWMutex
}

// TransactionRunnerMockRunRepeatableReadExpectation specifies expectation struct of the TransactionRunner.RunRepeatableRead
type TransactionRunnerMockRunRepeatableReadExpectation struct {
	mock    *TransactionRunnerMock
	params  *TransactionRunnerMockRunRepeatableReadParams
	results *TransactionRunnerMockRunRepeatableReadResults
	Counter uint64
}

// TransactionRunnerMockRunRepeatableReadParams contains parameters of the TransactionRunner.RunRepeatableRead
type TransactionRunnerMockRunRepeatableReadParams struct {
	ctx  context.Context
	txFn func(ctx context.Context) error
}

// TransactionRunnerMockRunRepeatableReadResults contains results of the TransactionRunner.RunRepeatableRead
type TransactionRunnerMockRunRepeatableReadResults struct {
	err error
}

// Expect sets up expected params for TransactionRunner.RunRepeatableRead
func (mmRunRepeatableRead *mTransactionRunnerMockRunRepeatableRead) Expect(ctx context.Context, txFn func(ctx context.Context) error) *mTransactionRunnerMockRunRepeatableRead {
	if mmRunRepeatableRead.mock.funcRunRepeatableRead != nil {
		mmRunRepeatableRead.mock.t.Fatalf("TransactionRunnerMock.RunRepeatableRead mock is already set by Set")
	}

	if mmRunRepeatableRead.defaultExpectation == nil {
		mmRunRepeatableRead.defaultExpectation = &TransactionRunnerMockRunRepeatableReadExpectation{}
	}

	mmRunRepeatableRead.defaultExpectation.params = &TransactionRunnerMockRunRepeatableReadParams{ctx, txFn}
	for _, e := range mmRunRepeatableRead.expectations {
		if minimock.Equal(e.params, mmRunRepeatableRead.defaultExpectation.params) {
			mmRunRepeatableRead.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRunRepeatableRead.defaultExpectation.params)
		}
	}

	return mmRunRepeatableRead
}

// Inspect accepts an inspector function that has same arguments as the TransactionRunner.RunRepeatableRead
func (mmRunRepeatableRead *mTransactionRunnerMockRunRepeatableRead) Inspect(f func(ctx context.Context, txFn func(ctx context.Context) error)) *mTransactionRunnerMockRunRepeatableRead {
	if mmRunRepeatableRead.mock.inspectFuncRunRepeatableRead != nil {
		mmRunRepeatableRead.mock.t.Fatalf("Inspect function is already set for TransactionRunnerMock.RunRepeatableRead")
	}

	mmRunRepeatableRead.mock.inspectFuncRunRepeatableRead = f

	return mmRunRepeatableRead
}

// Return sets up results that will be returned by TransactionRunner.RunRepeatableRead
func (mmRunRepeatableRead *mTransactionRunnerMockRunRepeatableRead) Return(err error) *TransactionRunnerMock {
	if mmRunRepeatableRead.mock.funcRunRepeatableRead != nil {
		mmRunRepeatableRead.mock.t.Fatalf("TransactionRunnerMock.RunRepeatableRead mock is already set by Set")
	}

	if mmRunRepeatableRead.defaultExpectation == nil {
		mmRunRepeatableRead.defaultExpectation = &TransactionRunnerMockRunRepeatableReadExpectation{mock: mmRunRepeatableRead.mock}
	}
	mmRunRepeatableRead.defaultExpectation.results = &TransactionRunnerMockRunRepeatableReadResults{err}
	return mmRunRepeatableRead.mock
}

// Set uses given function f to mock the TransactionRunner.RunRepeatableRead method
func (mmRunRepeatableRead *mTransactionRunnerMockRunRepeatableRead) Set(f func(ctx context.Context, txFn func(ctx context.Context) error) (err error)) *TransactionRunnerMock {
	if mmRunRepeatableRead.defaultExpectation != nil {
		mmRunRepeatableRead.mock.t.Fatalf("Default expectation is already set for the TransactionRunner.RunRepeatableRead method")
	}

	if len(mmRunRepeatableRead.expectations) > 0 {
		mmRunRepeatableRead.mock.t.Fatalf("Some expectations are already set for the TransactionRunner.RunRepeatableRead method")
	}

	mmRunRepeatableRead.mock.funcRunRepeatableRead = f
	return mmRunRepeatableRead.mock
}

// When sets expectation for the TransactionRunner.RunRepeatableRead which will trigger the result defined by the following
// Then helper
func (mmRunRepeatableRead *mTransactionRunnerMockRunRepeatableRead) When(ctx context.Context, txFn func(ctx context.Context) error) *TransactionRunnerMockRunRepeatableReadExpectation {
	if mmRunRepeatableRead.mock.funcRunRepeatableRead != nil {
		mmRunRepeatableRead.mock.t.Fatalf("TransactionRunnerMock.RunRepeatableRead mock is already set by Set")
	}

	expectation := &TransactionRunnerMockRunRepeatableReadExpectation{
		mock:   mmRunRepeatableRead.mock,
		params: &TransactionRunnerMockRunRepeatableReadParams{ctx, txFn},
	}
	mmRunRepeatableRead.expectations = append(mmRunRepeatableRead.expectations, expectation)
	return expectation
}

// Then sets up TransactionRunner.RunRepeatableRead return parameters for the expectation previously defined by the When method
func (e *TransactionRunnerMockRunRepeatableReadExpectation) Then(err error) *TransactionRunnerMock {
	e.results = &TransactionRunnerMockRunRepeatableReadResults{err}
	return e.mock
}

// RunRepeatableRead implements TransactionRunner
func (mmRunRepeatableRead *TransactionRunnerMock) RunRepeatableRead(ctx context.Context, txFn func(ctx context.Context) error) (err error) {
	mm_atomic.AddUint64(&mmRunRepeatableRead.beforeRunRepeatableReadCounter, 1)
	defer mm_atomic.AddUint64(&mmRunRepeatableRead.afterRunRepeatableReadCounter, 1)

	if mmRunRepeatableRead.inspectFuncRunRepeatableRead != nil {
		mmRunRepeatableRead.inspectFuncRunRepeatableRead(ctx, txFn)
	}

	mm_params := &TransactionRunnerMockRunRepeatableReadParams{ctx, txFn}

	// Record call args
	mmRunRepeatableRead.RunRepeatableReadMock.mutex.Lock()
	mmRunRepeatableRead.RunRepeatableReadMock.callArgs = append(mmRunRepeatableRead.RunRepeatableReadMock.callArgs, mm_params)
	mmRunRepeatableRead.RunRepeatableReadMock.mutex.Unlock()

	for _, e := range mmRunRepeatableRead.RunRepeatableReadMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRunRepeatableRead.RunRepeatableReadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRunRepeatableRead.RunRepeatableReadMock.defaultExpectation.Counter, 1)
		mm_want := mmRunRepeatableRead.RunRepeatableReadMock.defaultExpectation.params
		mm_got := TransactionRunnerMockRunRepeatableReadParams{ctx, txFn}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRunRepeatableRead.t.Errorf("TransactionRunnerMock.RunRepeatableRead got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRunRepeatableRead.RunRepeatableReadMock.defaultExpectation.results
		if mm_results == nil {
			mmRunRepeatableRead.t.Fatal("No results are set for the TransactionRunnerMock.RunRepeatableRead")
		}
		return (*mm_results).err
	}
	if mmRunRepeatableRead.funcRunRepeatableRead != nil {
		return mmRunRepeatableRead.funcRunRepeatableRead(ctx, txFn)
	}
	mmRunRepeatableRead.t.Fatalf("Unexpected call to TransactionRunnerMock.RunRepeatableRead. %v %v", ctx, txFn)
	return
}

// RunRepeatableReadAfterCounter returns a count of finished TransactionRunnerMock.RunRepeatableRead invocations
func (mmRunRepeatableRead *TransactionRunnerMock) RunRepeatableReadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRunRepeatableRead.afterRunRepeatableReadCounter)
}

// RunRepeatableReadBeforeCounter returns a count of TransactionRunnerMock.RunRepeatableRead invocations
func (mmRunRepeatableRead *TransactionRunnerMock) RunRepeatableReadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRunRepeatableRead.beforeRunRepeatableReadCounter)
}

// Calls returns a list of arguments used in each call to TransactionRunnerMock.RunRepeatableRead.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRunRepeatableRead *mTransactionRunnerMockRunRepeatableRead) Calls() []*TransactionRunnerMockRunRepeatableReadParams {
	mmRunRepeatableRead.mutex.RLock()

	argCopy := make([]*TransactionRunnerMockRunRepeatableReadParams, len(mmRunRepeatableRead.callArgs))
	copy(argCopy, mmRunRepeatableRead.callArgs)

	mmRunRepeatableRead.mutex.RUnlock()

	return argCopy
}

// MinimockRunRepeatableReadDone returns true if the count of the RunRepeatableRead invocations corresponds
// the number of defined expectations
func (m *TransactionRunnerMock) MinimockRunRepeatableReadDone() bool {
	for _, e := range m.RunRepeatableReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RunRepeatableReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRunRepeatableReadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRunRepeatableRead != nil && mm_atomic.LoadUint64(&m.afterRunRepeatableReadCounter) < 1 {
		return false
	}
	return true
}

// MinimockRunRepeatableReadInspect logs each unmet expectation
func (m *TransactionRunnerMock) MinimockRunRepeatableReadInspect() {
	for _, e := range m.RunRepeatableReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionRunnerMock.RunRepeatableRead with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RunRepeatableReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRunRepeatableReadCounter) < 1 {
		if m.RunRepeatableReadMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TransactionRunnerMock.RunRepeatableRead")
		} else {
			m.t.Errorf("Expected call to TransactionRunnerMock.RunRepeatableRead with params: %#v", *m.RunRepeatableReadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRunRepeatableRead != nil && mm_atomic.LoadUint64(&m.afterRunRepeatableReadCounter) < 1 {
		m.t.Error("Expected call to TransactionRunnerMock.RunRepeatableRead")
	}
}

type mTransactionRunnerMockRunSerializable struct {
	mock               *TransactionRunnerMock
	defaultExpectation *TransactionRunnerMockRunSerializableExpectation
	expectations       []*TransactionRunnerMockRunSerializableExpectation

	callArgs []*TransactionRunnerMockRunSerializableParams
	mutex    sync.RWMutex
}

// TransactionRunnerMockRunSerializableExpectation specifies expectation struct of the TransactionRunner.RunSerializable
type TransactionRunnerMockRunSerializableExpectation struct {
	mock    *TransactionRunnerMock
	params  *TransactionRunnerMockRunSerializableParams
	results *TransactionRunnerMockRunSerializableResults
	Counter uint64
}

// TransactionRunnerMockRunSerializableParams contains parameters of the TransactionRunner.RunSerializable
type TransactionRunnerMockRunSerializableParams struct {
	ctx  context.Context
	txFn func(ctx context.Context) error
}

// TransactionRunnerMockRunSerializableResults contains results of the TransactionRunner.RunSerializable
type TransactionRunnerMockRunSerializableResults struct {
	err error
}

// Expect sets up expected params for TransactionRunner.RunSerializable
func (mmRunSerializable *mTransactionRunnerMockRunSerializable) Expect(ctx context.Context, txFn func(ctx context.Context) error) *mTransactionRunnerMockRunSerializable {
	if mmRunSerializable.mock.funcRunSerializable != nil {
		mmRunSerializable.mock.t.Fatalf("TransactionRunnerMock.RunSerializable mock is already set by Set")
	}

	if mmRunSerializable.defaultExpectation == nil {
		mmRunSerializable.defaultExpectation = &TransactionRunnerMockRunSerializableExpectation{}
	}

	mmRunSerializable.defaultExpectation.params = &TransactionRunnerMockRunSerializableParams{ctx, txFn}
	for _, e := range mmRunSerializable.expectations {
		if minimock.Equal(e.params, mmRunSerializable.defaultExpectation.params) {
			mmRunSerializable.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRunSerializable.defaultExpectation.params)
		}
	}

	return mmRunSerializable
}

// Inspect accepts an inspector function that has same arguments as the TransactionRunner.RunSerializable
func (mmRunSerializable *mTransactionRunnerMockRunSerializable) Inspect(f func(ctx context.Context, txFn func(ctx context.Context) error)) *mTransactionRunnerMockRunSerializable {
	if mmRunSerializable.mock.inspectFuncRunSerializable != nil {
		mmRunSerializable.mock.t.Fatalf("Inspect function is already set for TransactionRunnerMock.RunSerializable")
	}

	mmRunSerializable.mock.inspectFuncRunSerializable = f

	return mmRunSerializable
}

// Return sets up results that will be returned by TransactionRunner.RunSerializable
func (mmRunSerializable *mTransactionRunnerMockRunSerializable) Return(err error) *TransactionRunnerMock {
	if mmRunSerializable.mock.funcRunSerializable != nil {
		mmRunSerializable.mock.t.Fatalf("TransactionRunnerMock.RunSerializable mock is already set by Set")
	}

	if mmRunSerializable.defaultExpectation == nil {
		mmRunSerializable.defaultExpectation = &TransactionRunnerMockRunSerializableExpectation{mock: mmRunSerializable.mock}
	}
	mmRunSerializable.defaultExpectation.results = &TransactionRunnerMockRunSerializableResults{err}
	return mmRunSerializable.mock
}

// Set uses given function f to mock the TransactionRunner.RunSerializable method
func (mmRunSerializable *mTransactionRunnerMockRunSerializable) Set(f func(ctx context.Context, txFn func(ctx context.Context) error) (err error)) *TransactionRunnerMock {
	if mmRunSerializable.defaultExpectation != nil {
		mmRunSerializable.mock.t.Fatalf("Default expectation is already set for the TransactionRunner.RunSerializable method")
	}

	if len(mmRunSerializable.expectations) > 0 {
		mmRunSerializable.mock.t.Fatalf("Some expectations are already set for the TransactionRunner.RunSerializable method")
	}

	mmRunSerializable.mock.funcRunSerializable = f
	return mmRunSerializable.mock
}

// When sets expectation for the TransactionRunner.RunSerializable which will trigger the result defined by the following
// Then helper
func (mmRunSerializable *mTransactionRunnerMockRunSerializable) When(ctx context.Context, txFn func(ctx context.Context) error) *TransactionRunnerMockRunSerializableExpectation {
	if mmRunSerializable.mock.funcRunSerializable != nil {
		mmRunSerializable.mock.t.Fatalf("TransactionRunnerMock.RunSerializable mock is already set by Set")
	}

	expectation := &TransactionRunnerMockRunSerializableExpectation{
		mock:   mmRunSerializable.mock,
		params: &TransactionRunnerMockRunSerializableParams{ctx, txFn},
	}
	mmRunSerializable.expectations = append(mmRunSerializable.expectations, expectation)
	return expectation
}

// Then sets up TransactionRunner.RunSerializable return parameters for the expectation previously defined by the When method
func (e *TransactionRunnerMockRunSerializableExpectation) Then(err error) *TransactionRunnerMock {
	e.results = &TransactionRunnerMockRunSerializableResults{err}
	return e.mock
}

// RunSerializable implements TransactionRunner
func (mmRunSerializable *TransactionRunnerMock) RunSerializable(ctx context.Context, txFn func(ctx context.Context) error) (err error) {
	mm_atomic.AddUint64(&mmRunSerializable.beforeRunSerializableCounter, 1)
	defer mm_atomic.AddUint64(&mmRunSerializable.afterRunSerializableCounter, 1)

	if mmRunSerializable.inspectFuncRunSerializable != nil {
		mmRunSerializable.inspectFuncRunSerializable(ctx, txFn)
	}

	mm_params := &TransactionRunnerMockRunSerializableParams{ctx, txFn}

	// Record call args
	mmRunSerializable.RunSerializableMock.mutex.Lock()
	mmRunSerializable.RunSerializableMock.callArgs = append(mmRunSerializable.RunSerializableMock.callArgs, mm_params)
	mmRunSerializable.RunSerializableMock.mutex.Unlock()

	for _, e := range mmRunSerializable.RunSerializableMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRunSerializable.RunSerializableMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRunSerializable.RunSerializableMock.defaultExpectation.Counter, 1)
		mm_want := mmRunSerializable.RunSerializableMock.defaultExpectation.params
		mm_got := TransactionRunnerMockRunSerializableParams{ctx, txFn}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRunSerializable.t.Errorf("TransactionRunnerMock.RunSerializable got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRunSerializable.RunSerializableMock.defaultExpectation.results
		if mm_results == nil {
			mmRunSerializable.t.Fatal("No results are set for the TransactionRunnerMock.RunSerializable")
		}
		return (*mm_results).err
	}
	if mmRunSerializable.funcRunSerializable != nil {
		return mmRunSerializable.funcRunSerializable(ctx, txFn)
	}
	mmRunSerializable.t.Fatalf("Unexpected call to TransactionRunnerMock.RunSerializable. %v %v", ctx, txFn)
	return
}

// RunSerializableAfterCounter returns a count of finished TransactionRunnerMock.RunSerializable invocations
func (mmRunSerializable *TransactionRunnerMock) RunSerializableAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRunSerializable.afterRunSerializableCounter)
}

// RunSerializableBeforeCounter returns a count of TransactionRunnerMock.RunSerializable invocations
func (mmRunSerializable *TransactionRunnerMock) RunSerializableBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRunSerializable.beforeRunSerializableCounter)
}

// Calls returns a list of arguments used in each call to TransactionRunnerMock.RunSerializable.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRunSerializable *mTransactionRunnerMockRunSerializable) Calls() []*TransactionRunnerMockRunSerializableParams {
	mmRunSerializable.mutex.RLock()

	argCopy := make([]*TransactionRunnerMockRunSerializableParams, len(mmRunSerializable.callArgs))
	copy(argCopy, mmRunSerializable.callArgs)

	mmRunSerializable.mutex.RUnlock()

	return argCopy
}

// MinimockRunSerializableDone returns true if the count of the RunSerializable invocations corresponds
// the number of defined expectations
func (m *TransactionRunnerMock) MinimockRunSerializableDone() bool {
	for _, e := range m.RunSerializableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RunSerializableMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRunSerializableCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRunSerializable != nil && mm_atomic.LoadUint64(&m.afterRunSerializableCounter) < 1 {
		return false
	}
	return true
}

// MinimockRunSerializableInspect logs each unmet expectation
func (m *TransactionRunnerMock) MinimockRunSerializableInspect() {
	for _, e := range m.RunSerializableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionRunnerMock.RunSerializable with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RunSerializableMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRunSerializableCounter) < 1 {
		if m.RunSerializableMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TransactionRunnerMock.RunSerializable")
		} else {
			m.t.Errorf("Expected call to TransactionRunnerMock.RunSerializable with params: %#v", *m.RunSerializableMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRunSerializable != nil && mm_atomic.LoadUint64(&m.afterRunSerializableCounter) < 1 {
		m.t.Error("Expected call to TransactionRunnerMock.RunSerializable")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TransactionRunnerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockRunInSavepointInspect()

		m.MinimockRunReadCommitedInspect()

		m.MinimockRunRepeatableReadInspect()

		m.MinimockRunSerializableInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TransactionRunnerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TransactionRunnerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockRunInSavepointDone() &&
		m.MinimockRunReadCommitedDone() &&
		m.MinimockRunRepeatableReadDone() &&
		m.MinimockRunSerializableDone()
}
