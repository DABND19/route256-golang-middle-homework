package domain

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/checkout/internal/domain.CartsRepository -o ./zzz_carts_repository.go -n CartsRepositoryMock

import (
	"context"
	"route256/checkout/internal/models"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartsRepositoryMock implements CartsRepository
type CartsRepositoryMock struct {
	t minimock.Tester

	funcCreateCartItem          func(ctx context.Context, user models.User, sku models.SKU, count models.ProductsCount) (err error)
	inspectFuncCreateCartItem   func(ctx context.Context, user models.User, sku models.SKU, count models.ProductsCount)
	afterCreateCartItemCounter  uint64
	beforeCreateCartItemCounter uint64
	CreateCartItemMock          mCartsRepositoryMockCreateCartItem

	funcDeleteCartItem          func(ctx context.Context, user models.User, sku models.SKU) (err error)
	inspectFuncDeleteCartItem   func(ctx context.Context, user models.User, sku models.SKU)
	afterDeleteCartItemCounter  uint64
	beforeDeleteCartItemCounter uint64
	DeleteCartItemMock          mCartsRepositoryMockDeleteCartItem

	funcGetCartItems          func(ctx context.Context, user models.User) (ca1 []models.CartItem, err error)
	inspectFuncGetCartItems   func(ctx context.Context, user models.User)
	afterGetCartItemsCounter  uint64
	beforeGetCartItemsCounter uint64
	GetCartItemsMock          mCartsRepositoryMockGetCartItems

	funcUpdateCartItemProductsCount          func(ctx context.Context, user models.User, sku models.SKU, diff int32) (i1 int32, err error)
	inspectFuncUpdateCartItemProductsCount   func(ctx context.Context, user models.User, sku models.SKU, diff int32)
	afterUpdateCartItemProductsCountCounter  uint64
	beforeUpdateCartItemProductsCountCounter uint64
	UpdateCartItemProductsCountMock          mCartsRepositoryMockUpdateCartItemProductsCount
}

// NewCartsRepositoryMock returns a mock for CartsRepository
func NewCartsRepositoryMock(t minimock.Tester) *CartsRepositoryMock {
	m := &CartsRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateCartItemMock = mCartsRepositoryMockCreateCartItem{mock: m}
	m.CreateCartItemMock.callArgs = []*CartsRepositoryMockCreateCartItemParams{}

	m.DeleteCartItemMock = mCartsRepositoryMockDeleteCartItem{mock: m}
	m.DeleteCartItemMock.callArgs = []*CartsRepositoryMockDeleteCartItemParams{}

	m.GetCartItemsMock = mCartsRepositoryMockGetCartItems{mock: m}
	m.GetCartItemsMock.callArgs = []*CartsRepositoryMockGetCartItemsParams{}

	m.UpdateCartItemProductsCountMock = mCartsRepositoryMockUpdateCartItemProductsCount{mock: m}
	m.UpdateCartItemProductsCountMock.callArgs = []*CartsRepositoryMockUpdateCartItemProductsCountParams{}

	return m
}

type mCartsRepositoryMockCreateCartItem struct {
	mock               *CartsRepositoryMock
	defaultExpectation *CartsRepositoryMockCreateCartItemExpectation
	expectations       []*CartsRepositoryMockCreateCartItemExpectation

	callArgs []*CartsRepositoryMockCreateCartItemParams
	mutex    sync.RWMutex
}

// CartsRepositoryMockCreateCartItemExpectation specifies expectation struct of the CartsRepository.CreateCartItem
type CartsRepositoryMockCreateCartItemExpectation struct {
	mock    *CartsRepositoryMock
	params  *CartsRepositoryMockCreateCartItemParams
	results *CartsRepositoryMockCreateCartItemResults
	Counter uint64
}

// CartsRepositoryMockCreateCartItemParams contains parameters of the CartsRepository.CreateCartItem
type CartsRepositoryMockCreateCartItemParams struct {
	ctx   context.Context
	user  models.User
	sku   models.SKU
	count models.ProductsCount
}

// CartsRepositoryMockCreateCartItemResults contains results of the CartsRepository.CreateCartItem
type CartsRepositoryMockCreateCartItemResults struct {
	err error
}

// Expect sets up expected params for CartsRepository.CreateCartItem
func (mmCreateCartItem *mCartsRepositoryMockCreateCartItem) Expect(ctx context.Context, user models.User, sku models.SKU, count models.ProductsCount) *mCartsRepositoryMockCreateCartItem {
	if mmCreateCartItem.mock.funcCreateCartItem != nil {
		mmCreateCartItem.mock.t.Fatalf("CartsRepositoryMock.CreateCartItem mock is already set by Set")
	}

	if mmCreateCartItem.defaultExpectation == nil {
		mmCreateCartItem.defaultExpectation = &CartsRepositoryMockCreateCartItemExpectation{}
	}

	mmCreateCartItem.defaultExpectation.params = &CartsRepositoryMockCreateCartItemParams{ctx, user, sku, count}
	for _, e := range mmCreateCartItem.expectations {
		if minimock.Equal(e.params, mmCreateCartItem.defaultExpectation.params) {
			mmCreateCartItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateCartItem.defaultExpectation.params)
		}
	}

	return mmCreateCartItem
}

// Inspect accepts an inspector function that has same arguments as the CartsRepository.CreateCartItem
func (mmCreateCartItem *mCartsRepositoryMockCreateCartItem) Inspect(f func(ctx context.Context, user models.User, sku models.SKU, count models.ProductsCount)) *mCartsRepositoryMockCreateCartItem {
	if mmCreateCartItem.mock.inspectFuncCreateCartItem != nil {
		mmCreateCartItem.mock.t.Fatalf("Inspect function is already set for CartsRepositoryMock.CreateCartItem")
	}

	mmCreateCartItem.mock.inspectFuncCreateCartItem = f

	return mmCreateCartItem
}

// Return sets up results that will be returned by CartsRepository.CreateCartItem
func (mmCreateCartItem *mCartsRepositoryMockCreateCartItem) Return(err error) *CartsRepositoryMock {
	if mmCreateCartItem.mock.funcCreateCartItem != nil {
		mmCreateCartItem.mock.t.Fatalf("CartsRepositoryMock.CreateCartItem mock is already set by Set")
	}

	if mmCreateCartItem.defaultExpectation == nil {
		mmCreateCartItem.defaultExpectation = &CartsRepositoryMockCreateCartItemExpectation{mock: mmCreateCartItem.mock}
	}
	mmCreateCartItem.defaultExpectation.results = &CartsRepositoryMockCreateCartItemResults{err}
	return mmCreateCartItem.mock
}

// Set uses given function f to mock the CartsRepository.CreateCartItem method
func (mmCreateCartItem *mCartsRepositoryMockCreateCartItem) Set(f func(ctx context.Context, user models.User, sku models.SKU, count models.ProductsCount) (err error)) *CartsRepositoryMock {
	if mmCreateCartItem.defaultExpectation != nil {
		mmCreateCartItem.mock.t.Fatalf("Default expectation is already set for the CartsRepository.CreateCartItem method")
	}

	if len(mmCreateCartItem.expectations) > 0 {
		mmCreateCartItem.mock.t.Fatalf("Some expectations are already set for the CartsRepository.CreateCartItem method")
	}

	mmCreateCartItem.mock.funcCreateCartItem = f
	return mmCreateCartItem.mock
}

// When sets expectation for the CartsRepository.CreateCartItem which will trigger the result defined by the following
// Then helper
func (mmCreateCartItem *mCartsRepositoryMockCreateCartItem) When(ctx context.Context, user models.User, sku models.SKU, count models.ProductsCount) *CartsRepositoryMockCreateCartItemExpectation {
	if mmCreateCartItem.mock.funcCreateCartItem != nil {
		mmCreateCartItem.mock.t.Fatalf("CartsRepositoryMock.CreateCartItem mock is already set by Set")
	}

	expectation := &CartsRepositoryMockCreateCartItemExpectation{
		mock:   mmCreateCartItem.mock,
		params: &CartsRepositoryMockCreateCartItemParams{ctx, user, sku, count},
	}
	mmCreateCartItem.expectations = append(mmCreateCartItem.expectations, expectation)
	return expectation
}

// Then sets up CartsRepository.CreateCartItem return parameters for the expectation previously defined by the When method
func (e *CartsRepositoryMockCreateCartItemExpectation) Then(err error) *CartsRepositoryMock {
	e.results = &CartsRepositoryMockCreateCartItemResults{err}
	return e.mock
}

// CreateCartItem implements CartsRepository
func (mmCreateCartItem *CartsRepositoryMock) CreateCartItem(ctx context.Context, user models.User, sku models.SKU, count models.ProductsCount) (err error) {
	mm_atomic.AddUint64(&mmCreateCartItem.beforeCreateCartItemCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateCartItem.afterCreateCartItemCounter, 1)

	if mmCreateCartItem.inspectFuncCreateCartItem != nil {
		mmCreateCartItem.inspectFuncCreateCartItem(ctx, user, sku, count)
	}

	mm_params := &CartsRepositoryMockCreateCartItemParams{ctx, user, sku, count}

	// Record call args
	mmCreateCartItem.CreateCartItemMock.mutex.Lock()
	mmCreateCartItem.CreateCartItemMock.callArgs = append(mmCreateCartItem.CreateCartItemMock.callArgs, mm_params)
	mmCreateCartItem.CreateCartItemMock.mutex.Unlock()

	for _, e := range mmCreateCartItem.CreateCartItemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateCartItem.CreateCartItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateCartItem.CreateCartItemMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateCartItem.CreateCartItemMock.defaultExpectation.params
		mm_got := CartsRepositoryMockCreateCartItemParams{ctx, user, sku, count}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateCartItem.t.Errorf("CartsRepositoryMock.CreateCartItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateCartItem.CreateCartItemMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateCartItem.t.Fatal("No results are set for the CartsRepositoryMock.CreateCartItem")
		}
		return (*mm_results).err
	}
	if mmCreateCartItem.funcCreateCartItem != nil {
		return mmCreateCartItem.funcCreateCartItem(ctx, user, sku, count)
	}
	mmCreateCartItem.t.Fatalf("Unexpected call to CartsRepositoryMock.CreateCartItem. %v %v %v %v", ctx, user, sku, count)
	return
}

// CreateCartItemAfterCounter returns a count of finished CartsRepositoryMock.CreateCartItem invocations
func (mmCreateCartItem *CartsRepositoryMock) CreateCartItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCartItem.afterCreateCartItemCounter)
}

// CreateCartItemBeforeCounter returns a count of CartsRepositoryMock.CreateCartItem invocations
func (mmCreateCartItem *CartsRepositoryMock) CreateCartItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCartItem.beforeCreateCartItemCounter)
}

// Calls returns a list of arguments used in each call to CartsRepositoryMock.CreateCartItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateCartItem *mCartsRepositoryMockCreateCartItem) Calls() []*CartsRepositoryMockCreateCartItemParams {
	mmCreateCartItem.mutex.RLock()

	argCopy := make([]*CartsRepositoryMockCreateCartItemParams, len(mmCreateCartItem.callArgs))
	copy(argCopy, mmCreateCartItem.callArgs)

	mmCreateCartItem.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCartItemDone returns true if the count of the CreateCartItem invocations corresponds
// the number of defined expectations
func (m *CartsRepositoryMock) MinimockCreateCartItemDone() bool {
	for _, e := range m.CreateCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCartItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCartItem != nil && mm_atomic.LoadUint64(&m.afterCreateCartItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateCartItemInspect logs each unmet expectation
func (m *CartsRepositoryMock) MinimockCreateCartItemInspect() {
	for _, e := range m.CreateCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartsRepositoryMock.CreateCartItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCartItemCounter) < 1 {
		if m.CreateCartItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartsRepositoryMock.CreateCartItem")
		} else {
			m.t.Errorf("Expected call to CartsRepositoryMock.CreateCartItem with params: %#v", *m.CreateCartItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCartItem != nil && mm_atomic.LoadUint64(&m.afterCreateCartItemCounter) < 1 {
		m.t.Error("Expected call to CartsRepositoryMock.CreateCartItem")
	}
}

type mCartsRepositoryMockDeleteCartItem struct {
	mock               *CartsRepositoryMock
	defaultExpectation *CartsRepositoryMockDeleteCartItemExpectation
	expectations       []*CartsRepositoryMockDeleteCartItemExpectation

	callArgs []*CartsRepositoryMockDeleteCartItemParams
	mutex    sync.RWMutex
}

// CartsRepositoryMockDeleteCartItemExpectation specifies expectation struct of the CartsRepository.DeleteCartItem
type CartsRepositoryMockDeleteCartItemExpectation struct {
	mock    *CartsRepositoryMock
	params  *CartsRepositoryMockDeleteCartItemParams
	results *CartsRepositoryMockDeleteCartItemResults
	Counter uint64
}

// CartsRepositoryMockDeleteCartItemParams contains parameters of the CartsRepository.DeleteCartItem
type CartsRepositoryMockDeleteCartItemParams struct {
	ctx  context.Context
	user models.User
	sku  models.SKU
}

// CartsRepositoryMockDeleteCartItemResults contains results of the CartsRepository.DeleteCartItem
type CartsRepositoryMockDeleteCartItemResults struct {
	err error
}

// Expect sets up expected params for CartsRepository.DeleteCartItem
func (mmDeleteCartItem *mCartsRepositoryMockDeleteCartItem) Expect(ctx context.Context, user models.User, sku models.SKU) *mCartsRepositoryMockDeleteCartItem {
	if mmDeleteCartItem.mock.funcDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartsRepositoryMock.DeleteCartItem mock is already set by Set")
	}

	if mmDeleteCartItem.defaultExpectation == nil {
		mmDeleteCartItem.defaultExpectation = &CartsRepositoryMockDeleteCartItemExpectation{}
	}

	mmDeleteCartItem.defaultExpectation.params = &CartsRepositoryMockDeleteCartItemParams{ctx, user, sku}
	for _, e := range mmDeleteCartItem.expectations {
		if minimock.Equal(e.params, mmDeleteCartItem.defaultExpectation.params) {
			mmDeleteCartItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCartItem.defaultExpectation.params)
		}
	}

	return mmDeleteCartItem
}

// Inspect accepts an inspector function that has same arguments as the CartsRepository.DeleteCartItem
func (mmDeleteCartItem *mCartsRepositoryMockDeleteCartItem) Inspect(f func(ctx context.Context, user models.User, sku models.SKU)) *mCartsRepositoryMockDeleteCartItem {
	if mmDeleteCartItem.mock.inspectFuncDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("Inspect function is already set for CartsRepositoryMock.DeleteCartItem")
	}

	mmDeleteCartItem.mock.inspectFuncDeleteCartItem = f

	return mmDeleteCartItem
}

// Return sets up results that will be returned by CartsRepository.DeleteCartItem
func (mmDeleteCartItem *mCartsRepositoryMockDeleteCartItem) Return(err error) *CartsRepositoryMock {
	if mmDeleteCartItem.mock.funcDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartsRepositoryMock.DeleteCartItem mock is already set by Set")
	}

	if mmDeleteCartItem.defaultExpectation == nil {
		mmDeleteCartItem.defaultExpectation = &CartsRepositoryMockDeleteCartItemExpectation{mock: mmDeleteCartItem.mock}
	}
	mmDeleteCartItem.defaultExpectation.results = &CartsRepositoryMockDeleteCartItemResults{err}
	return mmDeleteCartItem.mock
}

// Set uses given function f to mock the CartsRepository.DeleteCartItem method
func (mmDeleteCartItem *mCartsRepositoryMockDeleteCartItem) Set(f func(ctx context.Context, user models.User, sku models.SKU) (err error)) *CartsRepositoryMock {
	if mmDeleteCartItem.defaultExpectation != nil {
		mmDeleteCartItem.mock.t.Fatalf("Default expectation is already set for the CartsRepository.DeleteCartItem method")
	}

	if len(mmDeleteCartItem.expectations) > 0 {
		mmDeleteCartItem.mock.t.Fatalf("Some expectations are already set for the CartsRepository.DeleteCartItem method")
	}

	mmDeleteCartItem.mock.funcDeleteCartItem = f
	return mmDeleteCartItem.mock
}

// When sets expectation for the CartsRepository.DeleteCartItem which will trigger the result defined by the following
// Then helper
func (mmDeleteCartItem *mCartsRepositoryMockDeleteCartItem) When(ctx context.Context, user models.User, sku models.SKU) *CartsRepositoryMockDeleteCartItemExpectation {
	if mmDeleteCartItem.mock.funcDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartsRepositoryMock.DeleteCartItem mock is already set by Set")
	}

	expectation := &CartsRepositoryMockDeleteCartItemExpectation{
		mock:   mmDeleteCartItem.mock,
		params: &CartsRepositoryMockDeleteCartItemParams{ctx, user, sku},
	}
	mmDeleteCartItem.expectations = append(mmDeleteCartItem.expectations, expectation)
	return expectation
}

// Then sets up CartsRepository.DeleteCartItem return parameters for the expectation previously defined by the When method
func (e *CartsRepositoryMockDeleteCartItemExpectation) Then(err error) *CartsRepositoryMock {
	e.results = &CartsRepositoryMockDeleteCartItemResults{err}
	return e.mock
}

// DeleteCartItem implements CartsRepository
func (mmDeleteCartItem *CartsRepositoryMock) DeleteCartItem(ctx context.Context, user models.User, sku models.SKU) (err error) {
	mm_atomic.AddUint64(&mmDeleteCartItem.beforeDeleteCartItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCartItem.afterDeleteCartItemCounter, 1)

	if mmDeleteCartItem.inspectFuncDeleteCartItem != nil {
		mmDeleteCartItem.inspectFuncDeleteCartItem(ctx, user, sku)
	}

	mm_params := &CartsRepositoryMockDeleteCartItemParams{ctx, user, sku}

	// Record call args
	mmDeleteCartItem.DeleteCartItemMock.mutex.Lock()
	mmDeleteCartItem.DeleteCartItemMock.callArgs = append(mmDeleteCartItem.DeleteCartItemMock.callArgs, mm_params)
	mmDeleteCartItem.DeleteCartItemMock.mutex.Unlock()

	for _, e := range mmDeleteCartItem.DeleteCartItemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCartItem.DeleteCartItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.params
		mm_got := CartsRepositoryMockDeleteCartItemParams{ctx, user, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCartItem.t.Errorf("CartsRepositoryMock.DeleteCartItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCartItem.t.Fatal("No results are set for the CartsRepositoryMock.DeleteCartItem")
		}
		return (*mm_results).err
	}
	if mmDeleteCartItem.funcDeleteCartItem != nil {
		return mmDeleteCartItem.funcDeleteCartItem(ctx, user, sku)
	}
	mmDeleteCartItem.t.Fatalf("Unexpected call to CartsRepositoryMock.DeleteCartItem. %v %v %v", ctx, user, sku)
	return
}

// DeleteCartItemAfterCounter returns a count of finished CartsRepositoryMock.DeleteCartItem invocations
func (mmDeleteCartItem *CartsRepositoryMock) DeleteCartItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCartItem.afterDeleteCartItemCounter)
}

// DeleteCartItemBeforeCounter returns a count of CartsRepositoryMock.DeleteCartItem invocations
func (mmDeleteCartItem *CartsRepositoryMock) DeleteCartItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCartItem.beforeDeleteCartItemCounter)
}

// Calls returns a list of arguments used in each call to CartsRepositoryMock.DeleteCartItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCartItem *mCartsRepositoryMockDeleteCartItem) Calls() []*CartsRepositoryMockDeleteCartItemParams {
	mmDeleteCartItem.mutex.RLock()

	argCopy := make([]*CartsRepositoryMockDeleteCartItemParams, len(mmDeleteCartItem.callArgs))
	copy(argCopy, mmDeleteCartItem.callArgs)

	mmDeleteCartItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCartItemDone returns true if the count of the DeleteCartItem invocations corresponds
// the number of defined expectations
func (m *CartsRepositoryMock) MinimockDeleteCartItemDone() bool {
	for _, e := range m.DeleteCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCartItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCartItem != nil && mm_atomic.LoadUint64(&m.afterDeleteCartItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteCartItemInspect logs each unmet expectation
func (m *CartsRepositoryMock) MinimockDeleteCartItemInspect() {
	for _, e := range m.DeleteCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartsRepositoryMock.DeleteCartItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCartItemCounter) < 1 {
		if m.DeleteCartItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartsRepositoryMock.DeleteCartItem")
		} else {
			m.t.Errorf("Expected call to CartsRepositoryMock.DeleteCartItem with params: %#v", *m.DeleteCartItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCartItem != nil && mm_atomic.LoadUint64(&m.afterDeleteCartItemCounter) < 1 {
		m.t.Error("Expected call to CartsRepositoryMock.DeleteCartItem")
	}
}

type mCartsRepositoryMockGetCartItems struct {
	mock               *CartsRepositoryMock
	defaultExpectation *CartsRepositoryMockGetCartItemsExpectation
	expectations       []*CartsRepositoryMockGetCartItemsExpectation

	callArgs []*CartsRepositoryMockGetCartItemsParams
	mutex    sync.RWMutex
}

// CartsRepositoryMockGetCartItemsExpectation specifies expectation struct of the CartsRepository.GetCartItems
type CartsRepositoryMockGetCartItemsExpectation struct {
	mock    *CartsRepositoryMock
	params  *CartsRepositoryMockGetCartItemsParams
	results *CartsRepositoryMockGetCartItemsResults
	Counter uint64
}

// CartsRepositoryMockGetCartItemsParams contains parameters of the CartsRepository.GetCartItems
type CartsRepositoryMockGetCartItemsParams struct {
	ctx  context.Context
	user models.User
}

// CartsRepositoryMockGetCartItemsResults contains results of the CartsRepository.GetCartItems
type CartsRepositoryMockGetCartItemsResults struct {
	ca1 []models.CartItem
	err error
}

// Expect sets up expected params for CartsRepository.GetCartItems
func (mmGetCartItems *mCartsRepositoryMockGetCartItems) Expect(ctx context.Context, user models.User) *mCartsRepositoryMockGetCartItems {
	if mmGetCartItems.mock.funcGetCartItems != nil {
		mmGetCartItems.mock.t.Fatalf("CartsRepositoryMock.GetCartItems mock is already set by Set")
	}

	if mmGetCartItems.defaultExpectation == nil {
		mmGetCartItems.defaultExpectation = &CartsRepositoryMockGetCartItemsExpectation{}
	}

	mmGetCartItems.defaultExpectation.params = &CartsRepositoryMockGetCartItemsParams{ctx, user}
	for _, e := range mmGetCartItems.expectations {
		if minimock.Equal(e.params, mmGetCartItems.defaultExpectation.params) {
			mmGetCartItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartItems.defaultExpectation.params)
		}
	}

	return mmGetCartItems
}

// Inspect accepts an inspector function that has same arguments as the CartsRepository.GetCartItems
func (mmGetCartItems *mCartsRepositoryMockGetCartItems) Inspect(f func(ctx context.Context, user models.User)) *mCartsRepositoryMockGetCartItems {
	if mmGetCartItems.mock.inspectFuncGetCartItems != nil {
		mmGetCartItems.mock.t.Fatalf("Inspect function is already set for CartsRepositoryMock.GetCartItems")
	}

	mmGetCartItems.mock.inspectFuncGetCartItems = f

	return mmGetCartItems
}

// Return sets up results that will be returned by CartsRepository.GetCartItems
func (mmGetCartItems *mCartsRepositoryMockGetCartItems) Return(ca1 []models.CartItem, err error) *CartsRepositoryMock {
	if mmGetCartItems.mock.funcGetCartItems != nil {
		mmGetCartItems.mock.t.Fatalf("CartsRepositoryMock.GetCartItems mock is already set by Set")
	}

	if mmGetCartItems.defaultExpectation == nil {
		mmGetCartItems.defaultExpectation = &CartsRepositoryMockGetCartItemsExpectation{mock: mmGetCartItems.mock}
	}
	mmGetCartItems.defaultExpectation.results = &CartsRepositoryMockGetCartItemsResults{ca1, err}
	return mmGetCartItems.mock
}

// Set uses given function f to mock the CartsRepository.GetCartItems method
func (mmGetCartItems *mCartsRepositoryMockGetCartItems) Set(f func(ctx context.Context, user models.User) (ca1 []models.CartItem, err error)) *CartsRepositoryMock {
	if mmGetCartItems.defaultExpectation != nil {
		mmGetCartItems.mock.t.Fatalf("Default expectation is already set for the CartsRepository.GetCartItems method")
	}

	if len(mmGetCartItems.expectations) > 0 {
		mmGetCartItems.mock.t.Fatalf("Some expectations are already set for the CartsRepository.GetCartItems method")
	}

	mmGetCartItems.mock.funcGetCartItems = f
	return mmGetCartItems.mock
}

// When sets expectation for the CartsRepository.GetCartItems which will trigger the result defined by the following
// Then helper
func (mmGetCartItems *mCartsRepositoryMockGetCartItems) When(ctx context.Context, user models.User) *CartsRepositoryMockGetCartItemsExpectation {
	if mmGetCartItems.mock.funcGetCartItems != nil {
		mmGetCartItems.mock.t.Fatalf("CartsRepositoryMock.GetCartItems mock is already set by Set")
	}

	expectation := &CartsRepositoryMockGetCartItemsExpectation{
		mock:   mmGetCartItems.mock,
		params: &CartsRepositoryMockGetCartItemsParams{ctx, user},
	}
	mmGetCartItems.expectations = append(mmGetCartItems.expectations, expectation)
	return expectation
}

// Then sets up CartsRepository.GetCartItems return parameters for the expectation previously defined by the When method
func (e *CartsRepositoryMockGetCartItemsExpectation) Then(ca1 []models.CartItem, err error) *CartsRepositoryMock {
	e.results = &CartsRepositoryMockGetCartItemsResults{ca1, err}
	return e.mock
}

// GetCartItems implements CartsRepository
func (mmGetCartItems *CartsRepositoryMock) GetCartItems(ctx context.Context, user models.User) (ca1 []models.CartItem, err error) {
	mm_atomic.AddUint64(&mmGetCartItems.beforeGetCartItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartItems.afterGetCartItemsCounter, 1)

	if mmGetCartItems.inspectFuncGetCartItems != nil {
		mmGetCartItems.inspectFuncGetCartItems(ctx, user)
	}

	mm_params := &CartsRepositoryMockGetCartItemsParams{ctx, user}

	// Record call args
	mmGetCartItems.GetCartItemsMock.mutex.Lock()
	mmGetCartItems.GetCartItemsMock.callArgs = append(mmGetCartItems.GetCartItemsMock.callArgs, mm_params)
	mmGetCartItems.GetCartItemsMock.mutex.Unlock()

	for _, e := range mmGetCartItems.GetCartItemsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmGetCartItems.GetCartItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartItems.GetCartItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartItems.GetCartItemsMock.defaultExpectation.params
		mm_got := CartsRepositoryMockGetCartItemsParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartItems.t.Errorf("CartsRepositoryMock.GetCartItems got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartItems.GetCartItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartItems.t.Fatal("No results are set for the CartsRepositoryMock.GetCartItems")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmGetCartItems.funcGetCartItems != nil {
		return mmGetCartItems.funcGetCartItems(ctx, user)
	}
	mmGetCartItems.t.Fatalf("Unexpected call to CartsRepositoryMock.GetCartItems. %v %v", ctx, user)
	return
}

// GetCartItemsAfterCounter returns a count of finished CartsRepositoryMock.GetCartItems invocations
func (mmGetCartItems *CartsRepositoryMock) GetCartItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItems.afterGetCartItemsCounter)
}

// GetCartItemsBeforeCounter returns a count of CartsRepositoryMock.GetCartItems invocations
func (mmGetCartItems *CartsRepositoryMock) GetCartItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItems.beforeGetCartItemsCounter)
}

// Calls returns a list of arguments used in each call to CartsRepositoryMock.GetCartItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartItems *mCartsRepositoryMockGetCartItems) Calls() []*CartsRepositoryMockGetCartItemsParams {
	mmGetCartItems.mutex.RLock()

	argCopy := make([]*CartsRepositoryMockGetCartItemsParams, len(mmGetCartItems.callArgs))
	copy(argCopy, mmGetCartItems.callArgs)

	mmGetCartItems.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartItemsDone returns true if the count of the GetCartItems invocations corresponds
// the number of defined expectations
func (m *CartsRepositoryMock) MinimockGetCartItemsDone() bool {
	for _, e := range m.GetCartItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartItemsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItems != nil && mm_atomic.LoadUint64(&m.afterGetCartItemsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCartItemsInspect logs each unmet expectation
func (m *CartsRepositoryMock) MinimockGetCartItemsInspect() {
	for _, e := range m.GetCartItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartsRepositoryMock.GetCartItems with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartItemsCounter) < 1 {
		if m.GetCartItemsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartsRepositoryMock.GetCartItems")
		} else {
			m.t.Errorf("Expected call to CartsRepositoryMock.GetCartItems with params: %#v", *m.GetCartItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItems != nil && mm_atomic.LoadUint64(&m.afterGetCartItemsCounter) < 1 {
		m.t.Error("Expected call to CartsRepositoryMock.GetCartItems")
	}
}

type mCartsRepositoryMockUpdateCartItemProductsCount struct {
	mock               *CartsRepositoryMock
	defaultExpectation *CartsRepositoryMockUpdateCartItemProductsCountExpectation
	expectations       []*CartsRepositoryMockUpdateCartItemProductsCountExpectation

	callArgs []*CartsRepositoryMockUpdateCartItemProductsCountParams
	mutex    sync.RWMutex
}

// CartsRepositoryMockUpdateCartItemProductsCountExpectation specifies expectation struct of the CartsRepository.UpdateCartItemProductsCount
type CartsRepositoryMockUpdateCartItemProductsCountExpectation struct {
	mock    *CartsRepositoryMock
	params  *CartsRepositoryMockUpdateCartItemProductsCountParams
	results *CartsRepositoryMockUpdateCartItemProductsCountResults
	Counter uint64
}

// CartsRepositoryMockUpdateCartItemProductsCountParams contains parameters of the CartsRepository.UpdateCartItemProductsCount
type CartsRepositoryMockUpdateCartItemProductsCountParams struct {
	ctx  context.Context
	user models.User
	sku  models.SKU
	diff int32
}

// CartsRepositoryMockUpdateCartItemProductsCountResults contains results of the CartsRepository.UpdateCartItemProductsCount
type CartsRepositoryMockUpdateCartItemProductsCountResults struct {
	i1  int32
	err error
}

// Expect sets up expected params for CartsRepository.UpdateCartItemProductsCount
func (mmUpdateCartItemProductsCount *mCartsRepositoryMockUpdateCartItemProductsCount) Expect(ctx context.Context, user models.User, sku models.SKU, diff int32) *mCartsRepositoryMockUpdateCartItemProductsCount {
	if mmUpdateCartItemProductsCount.mock.funcUpdateCartItemProductsCount != nil {
		mmUpdateCartItemProductsCount.mock.t.Fatalf("CartsRepositoryMock.UpdateCartItemProductsCount mock is already set by Set")
	}

	if mmUpdateCartItemProductsCount.defaultExpectation == nil {
		mmUpdateCartItemProductsCount.defaultExpectation = &CartsRepositoryMockUpdateCartItemProductsCountExpectation{}
	}

	mmUpdateCartItemProductsCount.defaultExpectation.params = &CartsRepositoryMockUpdateCartItemProductsCountParams{ctx, user, sku, diff}
	for _, e := range mmUpdateCartItemProductsCount.expectations {
		if minimock.Equal(e.params, mmUpdateCartItemProductsCount.defaultExpectation.params) {
			mmUpdateCartItemProductsCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCartItemProductsCount.defaultExpectation.params)
		}
	}

	return mmUpdateCartItemProductsCount
}

// Inspect accepts an inspector function that has same arguments as the CartsRepository.UpdateCartItemProductsCount
func (mmUpdateCartItemProductsCount *mCartsRepositoryMockUpdateCartItemProductsCount) Inspect(f func(ctx context.Context, user models.User, sku models.SKU, diff int32)) *mCartsRepositoryMockUpdateCartItemProductsCount {
	if mmUpdateCartItemProductsCount.mock.inspectFuncUpdateCartItemProductsCount != nil {
		mmUpdateCartItemProductsCount.mock.t.Fatalf("Inspect function is already set for CartsRepositoryMock.UpdateCartItemProductsCount")
	}

	mmUpdateCartItemProductsCount.mock.inspectFuncUpdateCartItemProductsCount = f

	return mmUpdateCartItemProductsCount
}

// Return sets up results that will be returned by CartsRepository.UpdateCartItemProductsCount
func (mmUpdateCartItemProductsCount *mCartsRepositoryMockUpdateCartItemProductsCount) Return(i1 int32, err error) *CartsRepositoryMock {
	if mmUpdateCartItemProductsCount.mock.funcUpdateCartItemProductsCount != nil {
		mmUpdateCartItemProductsCount.mock.t.Fatalf("CartsRepositoryMock.UpdateCartItemProductsCount mock is already set by Set")
	}

	if mmUpdateCartItemProductsCount.defaultExpectation == nil {
		mmUpdateCartItemProductsCount.defaultExpectation = &CartsRepositoryMockUpdateCartItemProductsCountExpectation{mock: mmUpdateCartItemProductsCount.mock}
	}
	mmUpdateCartItemProductsCount.defaultExpectation.results = &CartsRepositoryMockUpdateCartItemProductsCountResults{i1, err}
	return mmUpdateCartItemProductsCount.mock
}

// Set uses given function f to mock the CartsRepository.UpdateCartItemProductsCount method
func (mmUpdateCartItemProductsCount *mCartsRepositoryMockUpdateCartItemProductsCount) Set(f func(ctx context.Context, user models.User, sku models.SKU, diff int32) (i1 int32, err error)) *CartsRepositoryMock {
	if mmUpdateCartItemProductsCount.defaultExpectation != nil {
		mmUpdateCartItemProductsCount.mock.t.Fatalf("Default expectation is already set for the CartsRepository.UpdateCartItemProductsCount method")
	}

	if len(mmUpdateCartItemProductsCount.expectations) > 0 {
		mmUpdateCartItemProductsCount.mock.t.Fatalf("Some expectations are already set for the CartsRepository.UpdateCartItemProductsCount method")
	}

	mmUpdateCartItemProductsCount.mock.funcUpdateCartItemProductsCount = f
	return mmUpdateCartItemProductsCount.mock
}

// When sets expectation for the CartsRepository.UpdateCartItemProductsCount which will trigger the result defined by the following
// Then helper
func (mmUpdateCartItemProductsCount *mCartsRepositoryMockUpdateCartItemProductsCount) When(ctx context.Context, user models.User, sku models.SKU, diff int32) *CartsRepositoryMockUpdateCartItemProductsCountExpectation {
	if mmUpdateCartItemProductsCount.mock.funcUpdateCartItemProductsCount != nil {
		mmUpdateCartItemProductsCount.mock.t.Fatalf("CartsRepositoryMock.UpdateCartItemProductsCount mock is already set by Set")
	}

	expectation := &CartsRepositoryMockUpdateCartItemProductsCountExpectation{
		mock:   mmUpdateCartItemProductsCount.mock,
		params: &CartsRepositoryMockUpdateCartItemProductsCountParams{ctx, user, sku, diff},
	}
	mmUpdateCartItemProductsCount.expectations = append(mmUpdateCartItemProductsCount.expectations, expectation)
	return expectation
}

// Then sets up CartsRepository.UpdateCartItemProductsCount return parameters for the expectation previously defined by the When method
func (e *CartsRepositoryMockUpdateCartItemProductsCountExpectation) Then(i1 int32, err error) *CartsRepositoryMock {
	e.results = &CartsRepositoryMockUpdateCartItemProductsCountResults{i1, err}
	return e.mock
}

// UpdateCartItemProductsCount implements CartsRepository
func (mmUpdateCartItemProductsCount *CartsRepositoryMock) UpdateCartItemProductsCount(ctx context.Context, user models.User, sku models.SKU, diff int32) (i1 int32, err error) {
	mm_atomic.AddUint64(&mmUpdateCartItemProductsCount.beforeUpdateCartItemProductsCountCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCartItemProductsCount.afterUpdateCartItemProductsCountCounter, 1)

	if mmUpdateCartItemProductsCount.inspectFuncUpdateCartItemProductsCount != nil {
		mmUpdateCartItemProductsCount.inspectFuncUpdateCartItemProductsCount(ctx, user, sku, diff)
	}

	mm_params := &CartsRepositoryMockUpdateCartItemProductsCountParams{ctx, user, sku, diff}

	// Record call args
	mmUpdateCartItemProductsCount.UpdateCartItemProductsCountMock.mutex.Lock()
	mmUpdateCartItemProductsCount.UpdateCartItemProductsCountMock.callArgs = append(mmUpdateCartItemProductsCount.UpdateCartItemProductsCountMock.callArgs, mm_params)
	mmUpdateCartItemProductsCount.UpdateCartItemProductsCountMock.mutex.Unlock()

	for _, e := range mmUpdateCartItemProductsCount.UpdateCartItemProductsCountMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmUpdateCartItemProductsCount.UpdateCartItemProductsCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCartItemProductsCount.UpdateCartItemProductsCountMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateCartItemProductsCount.UpdateCartItemProductsCountMock.defaultExpectation.params
		mm_got := CartsRepositoryMockUpdateCartItemProductsCountParams{ctx, user, sku, diff}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateCartItemProductsCount.t.Errorf("CartsRepositoryMock.UpdateCartItemProductsCount got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateCartItemProductsCount.UpdateCartItemProductsCountMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateCartItemProductsCount.t.Fatal("No results are set for the CartsRepositoryMock.UpdateCartItemProductsCount")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmUpdateCartItemProductsCount.funcUpdateCartItemProductsCount != nil {
		return mmUpdateCartItemProductsCount.funcUpdateCartItemProductsCount(ctx, user, sku, diff)
	}
	mmUpdateCartItemProductsCount.t.Fatalf("Unexpected call to CartsRepositoryMock.UpdateCartItemProductsCount. %v %v %v %v", ctx, user, sku, diff)
	return
}

// UpdateCartItemProductsCountAfterCounter returns a count of finished CartsRepositoryMock.UpdateCartItemProductsCount invocations
func (mmUpdateCartItemProductsCount *CartsRepositoryMock) UpdateCartItemProductsCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCartItemProductsCount.afterUpdateCartItemProductsCountCounter)
}

// UpdateCartItemProductsCountBeforeCounter returns a count of CartsRepositoryMock.UpdateCartItemProductsCount invocations
func (mmUpdateCartItemProductsCount *CartsRepositoryMock) UpdateCartItemProductsCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCartItemProductsCount.beforeUpdateCartItemProductsCountCounter)
}

// Calls returns a list of arguments used in each call to CartsRepositoryMock.UpdateCartItemProductsCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCartItemProductsCount *mCartsRepositoryMockUpdateCartItemProductsCount) Calls() []*CartsRepositoryMockUpdateCartItemProductsCountParams {
	mmUpdateCartItemProductsCount.mutex.RLock()

	argCopy := make([]*CartsRepositoryMockUpdateCartItemProductsCountParams, len(mmUpdateCartItemProductsCount.callArgs))
	copy(argCopy, mmUpdateCartItemProductsCount.callArgs)

	mmUpdateCartItemProductsCount.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCartItemProductsCountDone returns true if the count of the UpdateCartItemProductsCount invocations corresponds
// the number of defined expectations
func (m *CartsRepositoryMock) MinimockUpdateCartItemProductsCountDone() bool {
	for _, e := range m.UpdateCartItemProductsCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCartItemProductsCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCartItemProductsCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCartItemProductsCount != nil && mm_atomic.LoadUint64(&m.afterUpdateCartItemProductsCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateCartItemProductsCountInspect logs each unmet expectation
func (m *CartsRepositoryMock) MinimockUpdateCartItemProductsCountInspect() {
	for _, e := range m.UpdateCartItemProductsCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartsRepositoryMock.UpdateCartItemProductsCount with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCartItemProductsCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCartItemProductsCountCounter) < 1 {
		if m.UpdateCartItemProductsCountMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartsRepositoryMock.UpdateCartItemProductsCount")
		} else {
			m.t.Errorf("Expected call to CartsRepositoryMock.UpdateCartItemProductsCount with params: %#v", *m.UpdateCartItemProductsCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCartItemProductsCount != nil && mm_atomic.LoadUint64(&m.afterUpdateCartItemProductsCountCounter) < 1 {
		m.t.Error("Expected call to CartsRepositoryMock.UpdateCartItemProductsCount")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartsRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateCartItemInspect()

		m.MinimockDeleteCartItemInspect()

		m.MinimockGetCartItemsInspect()

		m.MinimockUpdateCartItemProductsCountInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartsRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartsRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateCartItemDone() &&
		m.MinimockDeleteCartItemDone() &&
		m.MinimockGetCartItemsDone() &&
		m.MinimockUpdateCartItemProductsCountDone()
}
